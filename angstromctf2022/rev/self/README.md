# self

## Challenge

![Challenge Card](./resources/challenge.png)

The challenge is a binary executable that will print the flag when run.

However, running it as it is given require waiting an impractical amount of time.
Therefore, we must reverse engineer the program to find a way to speed up this process.

### High Level IL (Generated by Binary Ninja)

```c
int32_t main(int32_t argc, char** argv, char** envp)
    int32_t rdx = data_6038
    int32_t rbx = 0x800
    do
        uint32_t rax_3 = rdx u>> 0x18
        bool cond:0_1 = rax_3 u<= 0xd6
        if (rax_3 == 0xd6)
            *(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) = *(&data_4038 + (zx.q(rdx & 0xfff) << 2))
        else if (cond:0_1)
            bool cond:1_1 = rax_3 u<= 0x18
            if (rax_3 == 0x18)
                uint64_t rax_29 = zx.q(rdx u>> 0xc & 0xfff)
                *(&data_4038 + (rax_29 << 2)) = *(&data_4038 + (rax_29 << 2)) ^ *(&data_4038 + (zx.q(rdx & 0xfff) << 2))
            else if (cond:1_1)
                if (rax_3 == 0x16)
                    uint64_t rax_16 = zx.q(rdx u>> 0xc & 0xfff)
                    int32_t rcx_4 = *(&data_4038 + (rax_16 << 2))
                    int32_t rcx_6 = (rcx_4 + *(&data_4038 + (zx.q(rdx & 0xfff) << 2))) & 0xffffff
                    *(&data_4038 + (rax_16 << 2)) = rcx_4 & 0xff000000
                    uint64_t rax_20 = zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff)
                    *(&data_4038 + (rax_20 << 2)) = *(&data_4038 + (rax_20 << 2)) + rcx_6
                else
                    if (rax_3 != 0x17)
                        break
                    uint64_t rax_7 = zx.q(rdx u>> 0xc & 0xfff)
                    int32_t rcx_1 = *(&data_4038 + (rax_7 << 2))
                    int32_t rcx_3 = (rcx_1 - *(&data_4038 + (zx.q(rdx & 0xfff) << 2))) & 0xffffff
                    *(&data_4038 + (rax_7 << 2)) = rcx_1 & 0xff000000
                    uint64_t rax_11 = zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff)
                    *(&data_4038 + (rax_11 << 2)) = *(&data_4038 + (rax_11 << 2)) + rcx_3
            else if (rax_3 == 0x69)
                int32_t rcx_7 = 1
                if (*(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) == 0)
                    rcx_7 = rdx & 0xfff
                rbx = (rbx + rcx_7 - 1) & 0xfff
            else
                if (rax_3 != 0xa6)
                    break
                rbx = rdx u>> 0xc & 0xfff
        else
            bool cond:2_1 = rax_3 u<= 0xf7
            if (rax_3 == 0xf7)
                *(&data_4038 + (zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff) << 2)) = getc(fp: stdin) | (*(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) & 0xff000000)
            else
                if (not(cond:2_1) && rax_3 != 0xff)
                    break
                if (cond:2_1)
                    if (rax_3 == 0xd8)
                        uint64_t rcx_11 = zx.q(rdx u>> 0xc & 0xfff)
                        *(&data_4038 + (rcx_11 << 2)) = (rdx & 0xfff) | (*(&data_4038 + (rcx_11 << 2)) & 0xff000000)
                    else
                        if (rax_3 != 0xf6)
                            break
                        putc(c: *(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) & 0xffffff, fp: stdout)
        uint64_t rax_1 = zx.q(rbx + 1)
        rdx = *(&data_4038 + (rax_1 << 2))
        rbx = rax_1.d
    while (rdx != 0)
    return 0
```

## Dissassembly CFG (Generated by Binary Ninja)

![Challenge Card](./resources/cfg.png)

## Summary

- Figure out that the program is a virtual machine which runs bytecode stored in its data.
- Reverse engineer the virtual machine to learn how the operations behave.
- Disassemble the bytecode in the binary data.
- Reverse engineer the bytecode and patch out extra code.

## Solution

The first step is to figure out how the program works.

If we were to try running the program, we would get no response but the program would not terminate, regardless of what we tried sending.
If we watch the program in GDB, it seems to loop indefinitely within the `main()` function.

Let's look at the `main()` function to see if we can decipher what it's doing.

We can see that most of the logic is contained within a main loop, with only a couple variable definitions before the loop.
Also note that RBX is incremented with every iteration, and RDX is read from a value in data at an offset dependent on RBX.
We can also see that RDX is used at the start of each loop to define RAX, which is used as the condition for almost all of the branches.

```c
00001050  int32_t main(int32_t argc, char** argv, char** envp)
00001052      int32_t rdx = data_6038
00001061      int32_t rbx = 0x800
000010ac      do
000010b0          uint32_t rax_3 = rdx u>> 0x18

                  ...

000010a0          uint64_t rax_1 = zx.q(rbx + 1)
000010a3          rdx = *(&data_4038 + (rax_1 << 2))
000010a7          rbx = rax_1.d
000010a7      while (rdx != 0)
000010da      return 0
```

### Extracting types

Let's drop down to medium level IL to see if we can determine the types of these variables:

```c
000010a0  rax_1 = zx.q(rbx + 1)
000010a3  rdx = [data_4038 + (rax_1 << 2)].d
000010a7  rbx = rax_1.eax
000010ac  if (rdx == 0) then 23 @ 0x10d5 else 3 @ 0x10ae
```

We can see that RDX and RBX are both actually 4 bytes.
Also, `rax_1` is being multiplied by 4 to use as an offset from `data_4038` and read 4 bytes.
Thus, it is likely that `data_4038` is an array that stores elements of size 4.
Also, RDX is likely to be an unsigned integer as it it used in an unsigned right shift.
Using this information, let's set the type of these variables as `uint32_t`.

We can see that RBX initially points at `data_6038`, but is set relative to `data_4038` for the remainder of the program.
The bytes between 0x4038 and 0x6038 are null, while there is non-null data after 0x6038.
We have to consider whether we should treat these as two separate arrays or as one large array.
`data_6038` does start with data, and is the starting point for RDX, which implies it could be a separate array.
However, since everything is indexed from `data_4038`, I figured it would be easier if they were treated as a single array.

We also have to figure out where `data_4038` ends then.
From our brief look at the `main()` function, there doesn't appear to be an upper limit to RBX except what can be stored in 4 bytes.
There also aren't any references to data beyond what we've gone over.
Everything seems to be referenced relative to `data_4038`.
Therefore, let's set the size to occupy the entire data section after it, which gives it a size of 0xfff integers.
Let's also call it `data_arr` from here on.

### Understanding the branches

### Extracting instruction definition

### Disassembly

### Converting to Python

### Patching

## Scripts

## Flag

```
actf{the_flag_was_you_all_along}
```
