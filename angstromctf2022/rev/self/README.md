# self

## Challenge

![Challenge Card](./resources/challenge.png)

The challenge is a binary executable that will print the flag when run.

However, running it as it is given require waiting an impractical amount of time.
Therefore, we must reverse engineer the program to find a way to speed up this process.

### High Level IL (Generated by Binary Ninja)

```c
int32_t main(int32_t argc, char** argv, char** envp)
    int32_t rdx = data_6038
    int32_t rbx = 0x800
    do
        uint32_t rax_3 = rdx u>> 0x18
        bool cond:0_1 = rax_3 u<= 0xd6
        if (rax_3 == 0xd6)
            *(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) = *(&data_4038 + (zx.q(rdx & 0xfff) << 2))
        else if (cond:0_1)
            bool cond:1_1 = rax_3 u<= 0x18
            if (rax_3 == 0x18)
                uint64_t rax_29 = zx.q(rdx u>> 0xc & 0xfff)
                *(&data_4038 + (rax_29 << 2)) = *(&data_4038 + (rax_29 << 2)) ^ *(&data_4038 + (zx.q(rdx & 0xfff) << 2))
            else if (cond:1_1)
                if (rax_3 == 0x16)
                    uint64_t rax_16 = zx.q(rdx u>> 0xc & 0xfff)
                    int32_t rcx_4 = *(&data_4038 + (rax_16 << 2))
                    int32_t rcx_6 = (rcx_4 + *(&data_4038 + (zx.q(rdx & 0xfff) << 2))) & 0xffffff
                    *(&data_4038 + (rax_16 << 2)) = rcx_4 & 0xff000000
                    uint64_t rax_20 = zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff)
                    *(&data_4038 + (rax_20 << 2)) = *(&data_4038 + (rax_20 << 2)) + rcx_6
                else
                    if (rax_3 != 0x17)
                        break
                    uint64_t rax_7 = zx.q(rdx u>> 0xc & 0xfff)
                    int32_t rcx_1 = *(&data_4038 + (rax_7 << 2))
                    int32_t rcx_3 = (rcx_1 - *(&data_4038 + (zx.q(rdx & 0xfff) << 2))) & 0xffffff
                    *(&data_4038 + (rax_7 << 2)) = rcx_1 & 0xff000000
                    uint64_t rax_11 = zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff)
                    *(&data_4038 + (rax_11 << 2)) = *(&data_4038 + (rax_11 << 2)) + rcx_3
            else if (rax_3 == 0x69)
                int32_t rcx_7 = 1
                if (*(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) == 0)
                    rcx_7 = rdx & 0xfff
                rbx = (rbx + rcx_7 - 1) & 0xfff
            else
                if (rax_3 != 0xa6)
                    break
                rbx = rdx u>> 0xc & 0xfff
        else
            bool cond:2_1 = rax_3 u<= 0xf7
            if (rax_3 == 0xf7)
                *(&data_4038 + (zx.q(*(&data_4038 + (zx.q(rbx) << 2)) u>> 0xc & 0xfff) << 2)) = getc(fp: stdin) | (*(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) & 0xff000000)
            else
                if (not(cond:2_1) && rax_3 != 0xff)
                    break
                if (cond:2_1)
                    if (rax_3 == 0xd8)
                        uint64_t rcx_11 = zx.q(rdx u>> 0xc & 0xfff)
                        *(&data_4038 + (rcx_11 << 2)) = (rdx & 0xfff) | (*(&data_4038 + (rcx_11 << 2)) & 0xff000000)
                    else
                        if (rax_3 != 0xf6)
                            break
                        putc(c: *(&data_4038 + (zx.q(rdx u>> 0xc & 0xfff) << 2)) & 0xffffff, fp: stdout)
        uint64_t rax_1 = zx.q(rbx + 1)
        rdx = *(&data_4038 + (rax_1 << 2))
        rbx = rax_1.d
    while (rdx != 0)
    return 0
```

## Dissassembly CFG (Generated by Binary Ninja)

![Challenge Card](./resources/cfg.png)

## Summary

- Figure out that the program is a virtual machine which runs bytecode stored in its data.
- Reverse engineer the virtual machine to learn how the operations behave.
- Disassemble the bytecode in the binary data.
- Reverse engineer the bytecode and patch out extra code.

## Solution

The first step is to figure out how the program works.

If we were to try running the program, we would get no response but the program would not terminate, regardless of what we tried sending.
If we watch the program in GDB, it seems to loop indefinitely within the `main()` function.

Let's look at the `main()` function to see if we can decipher what it's doing.

### Understainding program behaviour

We can see that most of the logic is contained within a main loop, with only a couple variable definitions before the loop.
Also note that RBX is incremented with every iteration, and RDX is read from a value in data at an offset dependent on RBX.
We can also see that RDX is used at the start of each loop to define RAX, which is used as the condition for almost all of the branches.

```c
int32_t main(int32_t argc, char** argv, char** envp)
    int32_t rdx = data_6038
    int32_t rbx = 0x800
    do
        uint32_t rax_3 = rdx u>> 0x18

        ...

        uint64_t rax_1 = zx.q(rbx + 1)
        rdx = *(&data_4038 + (rax_1 << 2))
        rbx = rax_1.d
    while (rdx != 0)
    return 0
```



### Extracting instruction definition

### Disassembly

### Converting to Python

### Patching

## Scripts

## Flag

```
actf{the_flag_was_you_all_along}
```
